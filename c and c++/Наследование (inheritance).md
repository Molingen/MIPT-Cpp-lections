___

> Позволяет создавать новый класс на основе существующего. Новый класс автоматически получает (наследует) **поля, методы и функциональность** базового класса, но при этом может добавлять собственные уникальные свойства и поведение, а также **модифицировать унаследованное**

1. **Базовый класс (Base, superclass)** — класс, от которого происходит наследование.
2. **Производный класс (Derived, subclass)** — класс, который наследует свойства и методы базового.
---

### Объявление

пусть существует `class Base`, он объявлен и определен, тогда

```cpp 
class Derived : public Base {}
// наследование бывает private, protected и public

```

***Типы наследования:***

- **public**: все публичные и защищенные члены базового класса становятся публичными в производном классе. (видно ваще везде)
- **protected**: все публичные и защищенные члены базового класса становятся защищенными в производном классе. (все, что объявлено `protected` видно всем членам класса, а еще всем членам наследников: "то, что вы унаследовали, знают только те, к то сам будет от вас наследоваться")
- **private**: все публичные и защищенные члены базового класса становятся приватными в производном классе. (все, что объявлено `private` видно только внутри этого класса, а наследники не будут знать про это)

```cpp
class Derived : private Base {};
class Jopa : [any_type] Derived {};
// Жопа не знает, деривед наследник базы
// Жопа может обращаться к полям и методам дериведа,
// но не сможет обращаться к полям и методам базы 
```

***Важновое:***
- Конструкторы и деструкторы не наследуются.
- При создании объекта производного класса сначала вызывается конструктор базового класса, а затем конструктор производного класса.
- При уничтожении объекта сначала вызывается деструктор производного класса, а затем деструктор базового класса.

---

### Поиск и сокрытие имен при наследовании

Сокрытие имен в контексте наследования происходит, когда производный класс определяет метод с таким же именем, что и метод в базовом классе. Это приводит к тому, что метод базового класса становится недоступным через объект производного класса, если он не вызывается явно.

```cpp
class Base {
public:
	void show() {
		std::cout << "Base show" << std::endl;
	}
};

class Derived : public Base {
public:
	void show() {
		std::cout << "Derived show" << std::endl;
	}
};

int main() {
	Derived d;
	d.show(); // Вызовет Derived::show(int)
	d.Base::show(); // Явный вызов метода базового класса
	return 0;
}
```

Можно использовать слово `using` для разрешения сокрытия:

```cpp
class Derived : public Base {
public:
	using Base::show;
	// все функции шоу внесутся в эту область
	// видимости и будут доступны для вызова
	void show(int x) {
		std::cout << "Derived show with int: " << x << std::endl;
	}
};
```

---

### Различие классов и структур при наследовании

```cpp
struct Base {
	void f();
};
struct Derived : Base {
private:
	void f(int) { ... }
};

int main() {
	Derived d;
	d.f();
	// компилятор сначала выяснит проблему имен функций
	// потом уже узнает доступны они или нет
	// короче код такой работать не будет
}
```

---

### Тонкости запретов при public-наследовании от класса с private-наследованием 

```cpp
struct Granny {
	int a;
};
struct Mom : private Granny {
	int b;
};
struct Son : public Mom {
	int c;
	void f() {
		Mom m; // так можно
		Granny g; // так уже нельзя потому что
		// конструктор бабушки из сына не доступен
	}

	// так нельзя (даже если будет Granny& g), потому что
	// даже само название типа запрещено
	// в контексте сына Granny нельзя использовать
	// но если в Mom будет строка friend class Son, то можно
	void f2(Granny g) {
		Mom m;
	}

	// а так можно, ищем в глобальной области видимости
	void f2(Granny g) {
		Mom m;
	}
};

int main() {
	Son s;
	s.c;
	s.b;
	s.a; // не сработает
	s.Granny::a; // не сработает - приватное наследование Mom
}
```

---

# Множественное наследование (multiple inheritance)

> Один класс может перечислить через запятую тех, от кого он отнаследовался

```cpp
struct Parallelogram { int x; };
struct Rectangle : Parallelogram { int y; };
struct Rhombus : Parallelogram { int z ; };
struct Square : Rectangle, Rhombus { int t; };
```

Если создать `Square s;`, то его размер будет пять интов

---

### Проблема ромбовидного наследования


```
Square s;
s.x; // ошибка
s.Rhombus::x; // сработает 
```

Если посмотреть в пример выше, то можно заметить, что строка `s.x;` вызывает ошибку компиляции, ведь непонятно какой `x` вызывать `Rhombus::x` или `Rectangle::x`

Даже если объявить `Rectangle`, как приватного наследника `Parallelogram`, то обращение `s.x`; также выдаст ошибку (сначала происходит поиск имен, а уже потом проверка на их доступность)

---

### Проблема "Сын - прямой наследник бабушки"

```cpp
struct Granny { int x; };
struct Mom : public Granny { int y; };
struct Son : public Mom, public Granny { int z; };
```

При создании объекта `Son` будет две бабушки
Кполю `x` у `Granny`, которая наследуется `Son` напрямую, получить доступ никак нельзя (только с помощью виртуального наследования)

---

### Виртуальное наследование

Поможет сделать так, чтобы при множественном наследовании не создавалась копия базового класса

```cpp
struct Parallelogram { int x; };
struct Rectangle : virtual public Parallelogram { int y; };
struct Rhombus : virtual public Parallelogram { int z ; };
struct Square : Rectangle, Rhombus { int t; };
```

- `sizeof()` от  объекта типа `Square` будет даже больше, чем 4 инта, потому что `Rectangle` и `Rhombus` хранят не только одно общее поле от `Parallelogram`, но и указатель на это поле (каждый)

---

### Приведение типов между наследниками

```cpp
class Base {
	int a;
	void f();
};
class Derived : public Base {
	int b;
	void f();
};

Base b;
Derived d;

b = d; // d - частный случай b, произойдет срезка при копировании
// так делать нежелательно

Base& c = d; // а так можно делать

static_cast<Derived&>(c).f();
/*
ну типа так сработает, но если c - не деривед, то всё плохо
проверяет на этапе компиляции
*/

reinterpret_cast<Base&>(d);
/*
если наследование приватное, а к функции "f()" все таки
хочется обратиться (ну или к полю "а")
*/

dynamic_cast<Derived&>(c);
/*
снова получим ссылку на деривед
он проверяет можно ли так сделать (уже на этапе выполнения)
и, если что-то пошло не так - выбрасывает ошибку,
которую можно отловить с помощью try - catch
*/ 

d = b; // ошибка
```

---

### Виртуальные функции

- в основном в них заключается полиморфизм
Они позволяют реализовать полиморфизм времени выполнения. Когда вызвана виртуальная функция через указатель или ссылку на базовый класс, вызывается версия функции, определенная в классе, к которому фактически принадлежит объект.

```cpp
class B {
	void f();
};
class D : public Base {
	void f();
};

D d;
B& b = d;
b.f();
/*
вызовется функция из B, но если написать в нём
virtual void f();
то вызовется функция "f()" из класса D
*/ 

```

> если есть виртуальная функция, то обязательно должен быть виртуальный деструктор

---

### Виртуальный деструктор

Он используется для обеспечения правильного вызова деструкторов производных классов при удалении объектов через указатель на базовый класс. Это важно для предотвращения утечек памяти.

```cpp
Derived* d = new D();
Base* b = d;
delete b; // произойдет утечка памяти
```

Когда удаляется объект через указатель на базовый класс, и базовый класс не имеет виртуального деструктора, то вызывается только деструктор базового класса. Это может привести к тому, что деструкторы производных классов не будут вызваны.

---

### Абстрактные классы

Они используются для создания интерфейсов, которые могут быть реализованы в производных классах. Абстрактные классы содержат хотя бы одну чистую виртуальную функцию, которая не имеет реализации в базовом классе и должна быть реализована в производных классах.

Абстрактные классы запрещают создавать объекты своих типов.

***Чистые виртуальные функции:***
- Объявляются с использованием `= 0` в конце объявления функции.
- Производные классы обязаны реализовать эти функции, если они сами не являются абстрактными.

```cpp
class Shape {
public:
    // Чистая виртуальная функция
    virtual void draw() = 0;

    // Виртуальный деструктор
    virtual ~Shape() {
        cout << "Деструктор Shape" << endl;
    }
};

class Circle : public Shape {
public:
    void draw() override {
        cout << "Рисуем круг" << endl;
    }

    ~Circle() override {
        cout << "Деструктор Circle" << endl;
    }
};

class Rectangle : public Shape {
public:
    void draw() override {
        cout << "Рисуем прямоугольник" << endl;
    }

    ~Rectangle() override {
        cout << "Деструктор Rectangle" << endl;
    }
};
```

---

### Ключевые слова override, final

Они используются для уточнения поведения виртуальных функций (и не только) в производных классах.

##### `override`

Ключевое слово `override` используется для явного указания, что функция в производном классе переопределяет виртуальную функцию из базового класса. Это помогает избежать ошибок, связанных с неправильным переопределением функций.

- Проверка на этапе компиляции

##### `final`

Запрещает наследоваться от класса 

***ИЛИ***

Оно используется для предотвращения дальнейшего переопределения виртуальной функции в производных классах. Это полезно, когда надо зафиксировать реализацию функции и не позволить производным классам изменять её поведение.

---

### Динамическое определение типа (оператор typeid)

Он используется для получения информации о типе объекта во время выполнения. Он возвращает объект типа `std::type_info`, который можно использовать для сравнения типов.

Долгие запросы и как то ваще не оч приятно (по правильному будет через шаблоны)

---