___
>если реализовывать методы и операторы не вне класса, то левым аргументом не может быть не объект класса

---

### Арифметические операторы

Оператор `+=` нужно реализовать нормально, а оператор `+` уже через `+=`, иначе он будет долго работать 

Также если оператор "+" реализован как метод класса, то он имеет только один параметр (правый операнд), левый - это this. Поэтому для того, чтобы иметь возможность складывать `5 + c`, оператор должен быть реализован как свободная функция, принимающая два аргумента, обычно дружественную для класса.

```cpp
C& operator += (const C& x) { 
	// реализация по честному
	return *this; 
};
/*
оператор "+", представленный ниже будет некомутативен, т.е.:
C c;
c + 5; - строка сработает
5 + c; - выдаст ошибку
потому что все операторы реализованные в классе принимают 
левым аргументом this
*/ 
C operator + (const C& x) const {
	C y = *this;
	return y += x;
}
/*
также можно будет реализовать такое:
C c1 = 3;
C c2 = 3;
c1 + c2 = 5;
но третья строчка rvalue = rvalue, при этом она скомпилириуется
чтобы это исправить нужно возвращать const
*/
const C operator + (const C& x, const C& y) {
	C z = x;
	z += y;
	return z;
}
```

Бинарные операции для класса всегда должны возвращать `const`, ведь если возвращать не `const`, то к тому, что они возвращают можно делать присваивание (в т.ч. постфиксный и префиксный инкремент/декремент)

 ---
### Операторы ввода/вывода

Определяется вне класса
френды там, все дела

---

### Операторы сравнения

как правильно реализовывать? (по мфти -  сначала реализовать оператор меньше, а уже остальное выразить через него)

```cpp
bool operator<(const C& x) const {
	// реализация
}

bool operator>(const C& x) const {
	return !(x<*this);
}

bool operator==(const C& x) const {
	return !(x<*this || x>*this);
}

bool operator!=(const C& x) const {
	return !(x==*this);
}

bool operator<=(const C& x) const {
	return !(x>*this);
}
```

---

### Операторы (унарные) "+" и "-"

унарный минус *не будет принимать аргументов* и возвращает *другой объект* этого же класса

---

### Операторы инкремента и декремента

1) ***Префиксный инкремент:***
Возвращает ссылку на объект
```cpp
C& operator++() {
	return *this+=1;
}
```

2) ***Постфиксный инкремент:***
Возвращает не ссылку, копирует весь объект (поэтому работает линейное время)
```cpp
const C operator++(int) {
	C x = *this;
	*this+=1;
	return x;
}
```

> Страуструп добавил фиктивный параметр типа `int` постфиксному инкременту, чтобы можно их было различать

---

### Оператор "\[\]"

Должен возвращать ссылку на `char`
должна быть неконстантной, хоть поля класса и не меняет, но возвращает неконстантную ссылку на поле

```cpp
char& operator[](int index) {
	return arr[i];
}
```

Если строка константная, то придется писать второй оператор квадратные скобки

```cpp
const char& operator[](int index) const {
	return arr[i];
}
```

---

### Оператор "()"

Позволяет некоторые объекты использовать в качестве функции (функциональные объекты - функторы)

```cpp
// функциональный класс
class GraterThanZero {
public:
	bool operator()(int x) {
		return x>0;
	}
};

// а сам объект - функтор
int main() {
	GraterThanZero gtz;
	std::cout << gtz(3);
}
```

---

### Операторы "&&", "||", "," а также "\*", "&", "->"

можно перегрузить, но лучше такое не делать (у первых трех и последних двух)
- у первых трех меняется семантика вызова, а значит они теряют свойство вычисления слева направо

Когда будет реализация "умных указателей" придется перегружать умную звездочку

---

### Перегрузка C-style cast

без параметров и не надо писать возвращаемое значение
рекомендуется делать `explicit`

```cpp
operator int() { ... }
```

---
