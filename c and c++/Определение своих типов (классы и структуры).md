___

>***Правило трёх:*** Если ваш класс требует определения конструктора копирования или оператора присваивания или деструктора (хотя бы чего то одного), значит он требует определения всех трех вещей

---

### Классы и структуры

Классы в C++ - просто пользовательские типы данных

```cpp
// если не написать метки, то все в классе будет private
class C { 
	public:
		...
	private:
		...
} c; 
// c - идентификатор класса
```

***Модификаторы доступа*** (`private` и `public`)
иногда в привате пишутся некоторые методы, которые не должны быть доступны извне

```cpp
struct S {
	int x;
} s;
// s - идентификатор структуры
```

В современном C++ `class` и `struct` почти полные синонимы. В чем различие? __(оставить ссылку на [Наследование (inheritance)](Наследование%20(inheritance).md))__
- в `class` все по умолчанию `private`, а в `struct` `public`
- наследование `class` по умолчанию `private`, а наследование `struct` по умолчанию `public`

___
### Конструкторы

```cpp
class C {
public:
	C (int x_) {x = x_;}
	C () {/*тут можно задать конструктор по умолчанию, 
	а можно оставить пустым*/} // конструктор по умолчанию
private:
	int x;
};

class String {
public:

	// конструктор
	String(const char* str_, int size_) {
		str = new char[size_];
		for (int i = 0; i < size_, i++) {
			str[i] = str_[i]; // хз, наверное так
		}
	}
	
	String() = default;
	/* компилятор сгенерирует конструктор по умолчанию и
	строка с вызовом s2 в мейне сработает,  */

	String() = delete;
	/* запрет компилятору генерировать конструктор по умолчанию 
	при условии, что конструкторов вообще нет нет */ 
private:
	char* str;
	int size;
};

int main() {
	C x; // тут вызовется конструктор по умолчанию

	String s = String("ass", 3);
	String s1("ass", 3);
	String s2; /* так не будет работать, т.к. есть 
	правило генерации конструкторов по умолчанию - 
	компилятор сам его сгенерирует, но, если пользователь 
	уже написал свой конструктор - компилятор не будет 
	генерировать конструктор по умолчанию */
}
```

___

### Деструкторы

Функция, которая вызывается, когда объект выходит из области видимости. Он нужен, если в конструкторе происходило выделение памяти

```cpp
class String {
public:
	// конструктор
	String(const char* str_, int size_) {
		str = new char[size_];
		for (int i = 0; i < size_; i++) {
			str[i] = str_[i]; // хз, наверное так
		}
	}

	// деструктор, в него нельзя передавать переменные
	~String() {
		delete[] str;
	}
private:
	char* str;
	int size;
};
```

Если явно не объявлять деструктор, то компилятор его сам сгенерирует, но "деструктор по умолчанию" не делает никаких нетривиальных операций, т.е. выделенная память в конструкторе таким деструктором не удалится

___

### Конструктор копирования

Компилятор тоже умеет генерировать его по умолчанию

```cpp
String(const String& s_) {
	// тело конструктора копирования
}
/* он обяз должен принимать константную ссылку, 
иначе будет рекурсивный вызов конструктора копирования 
и рантайм еррор */ 

int main() {
	String s("asd", 3);
	String s1 = s;
	return 0;
}
```

---

### Операторы "." , "->" и ключевое слово *this*

- Оператор точка используется для доступа к членам объекта или структуры через объект или ссылку на объект.
- Оператор стрелочка используется для доступа к членам объекта через указатель на объект. `(*p).a ~ p->a`

- Ключевое слово `this` представляет собой указатель на текущий объект, в контексте которого вызывается метод. Оно используется для доступа к членам текущего объекта и позволяет различать члены класса и параметры или локальные переменные метода с такими же именами.

--- 

### Оператор присваивания

Сам оператор возвращает ссылку на тип, с которым работаем

```cpp
// с лекции мфти
String& operator = (const String& s) {
	if (this == &s) { return *this; }
	// проверка на самоприсваивание
	delete[] str;
	str = new char[s.size];
	std::strcpy(str, s);
	return *this;
}

// нейронки
String& operator = (const String& other) { 
	if (this != &other) { // проверка на самоприсваивание
		delete[] str; // освобождение старой памяти
		if (other.str) { 
			str = new char[std::strlen(other.str) + 1];
			std::strcpy(str, other.str); 
		} else {
			str = nullptr;
		}
	} 
	return *this;
}
```

---

### Списки инициализации в конструкторах

```cpp
C(const int x, int& y) : x(x), y(y) {}
```

Лучше пользоваться списками инициализации (то что после двоеточия), а не присваиванием в конструкторах, (решает проблему присваивания полей, которым нельзя делать присваивание, например: `private: const int x = 3; int& y;`)

---

### Ключевое слово explicit (скорее вопрос для собеса)

Запрещает неявные конверсии типов. Писать перед конструкторами (если это не конструктор копирования) (можно и перед функциями)

```cpp
String s = 'a';
/*
преобразует char в int и будет у нас лежать много символов,
а не буква а
*/
```

---

### Константные методы (страдать и рвать очко)

- методы, которые позволяют читать/изменять поля класса - геттеры/сеттеры

```cpp
int size() { return size_; }
// это метод класса не допускающий вызов от константного объекта

const String s = "abc";
s.size; // будет ошибка компиляции
```

По умолчанию считается, что каждый метод класса имеет право менять поля этого класса, но если объект (в этом случае `s`) - константный, то поля класса менять нельзя, а метод `size()` потенциально может. Фиксится:

```cpp
int size() const { return size_; } 
```

Это метод класса допускающий вызов от константного объекта, но все поля внутри этого метода (где `return size_;`) будут константными, т.е. из этого метода нельзя будет вызвать никакие модифицирующие операции над полями объекта (иногда возвращает const this)

---

### Ключевое слово mutable

Оно используется для указания, что определенное поле класса может быть изменено даже если оно объявлено в объекте, который является константным. Это позволяет изменять состояние объекта, несмотря на то, что сам объект объявлен как `const`.
Можно использовать, например, для логирования и отладки.

---

### Ключевое слово friend

 Оно используется для предоставления классу, функции или другому типу доступа к закрытым (`private`) и защищенным (`protected`) членам другого или этого класса. Это позволяет нарушить правила инкапсуляции в определенных случаях, когда это необходимо для реализации тесного взаимодействия между классами или функциями.

---

### Делегирующие конструкторы

Делегирующие конструкторы в позволяют одному конструктору класса вызывать другой конструктор того же класса. Это полезно для избежания дублирования кода и обеспечения единообразия инициализации объектов.

```cpp
// Основной конструктор
Person(const std::string& name, int age) : name(name), age(age) { 
	std::cout << "Constructor with name and age" << std::endl;
}
	
// Делегирующий конструктор 
Person(const std::string& name) : Person(name, 0) {
	// Делегирование конструктору с двумя параметрами
	std::cout << "Delegating constructor with name" << std::endl;
}
```

---

### Ключевое слово static

Статические члены класса принадлежат классу, а не конкретному объекту. Можно некоторое поле класса объявить `static`, это будет означать, что поле не принадлежит ни одному из объектов 
- **Статические переменные класса**: Общие для всех объектов класса.
- **Статические методы класса**: Могут быть вызваны без создания объекта класса и не имеют доступа к нестатическим членам класса.

Например, можно подсчитать количество вызовов функции (в теле функции объявить `static int x;` и каждый раз увеличивать при вызове), т.к. оно статик, то компилятор будет пропускать строку эту строку, не инициализируя и сохраняя переменную до конца работы программы.

---

**Указатели на члены:**

```cpp
int C::*p = &C::a; // указатель на член класса
// пусть это указатель на поле класса
C c;
c.*p = 5; // оператор .*
```

Если `p` указатель не на поле, а на метод, то можно таким образом вызывать методы класса. (не то же самое что и указатель на функцию)

---

```cpp
class Srting {
public:
	String(const char* initialStr) {
		if (initialStr) {
			str = new char[std::strlen(initialStr) + 1];
			std::strcpy(str, initialStr);
		} else {
			str = nullptr;
		}
	
	String(const String& other) {
		if (other.str) {
			str = new char[std::strlen(other.str) + 1];
			std::strcpy(str, other.str);
		} else {
			str = nullptr;
		}
	}

	~String() {
		delete[] str;
	} 
private:
	char* str;
};

int main() {
	Srting s("ass");
	String s1 = s;
	return 0;
}
```

---

[[Перегрузка операторов]]